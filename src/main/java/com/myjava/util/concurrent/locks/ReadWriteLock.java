package com.myjava.util.concurrent.locks;

/**
 * {@code ReadWriteLock} 持有一堆关联的 {@link Lock 锁}，一个用于读操作一个用于写。
 * {@linkplain #readLock 读锁}被多个读线程同时持有，然而不能有写操作。
 * {@linkplain #writeLock 写锁}却是独占的。
 *
 * 所有的{@code ReadWriteLock}实现必须保证{@code writeLock}操作的内存同步也可以持有{@code readLock}。
 * 意思是，线程需要保证读锁可以看到在之前的写锁释放之后能看到所有的更新。
 *
 * 读写锁在访问共享数据相比于互斥锁具有更高层级的并发性。实际上同一时间只有一个线程（写线程）可以修改共享数据，
 * 大部分情况下任意数量的线程都可以并发的读取数据。
 * 理论上，相比于互斥锁，读写锁在并发中使用的增加会导致表现不错的实现。实际中这种增长只会在多处理器中可以发挥出来
 * 而且对于共享数据的访问模式是恰当的。
 *
 * 不管读写锁相对于互斥锁在性能上提升多少，它还是依赖于数据相比于改写具有更频繁的读场景，读和写操作的持续时间和
 * 数据的争用情况——同一时间访问和写入数据的线程数量。
 * 比如一个队列被初始化后被频繁的修改，而频繁的搜索也是（读写锁的）一个不错的应用场景。然而，如果更新变得频繁导致
 * 数据花费大部分的事件用于互斥操作，这样对比并发性能的增加没有什么益处。如果读操作对于读写锁事件没有太高负载那么
 * 增加了过多的花销，特别是许多读写锁的实现仍然可以通过一段短小的代码序列化所有线程。最终，只有实施一些监控才能看出
 * 你的应用到底适不适合使用读写锁。
 */
public interface ReadWriteLock {

    Lock readLock();

    Lock writeLock();
}
